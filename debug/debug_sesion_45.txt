{
  "contenido_md": "# Sesión 45: useEffect y simulación de carga\n\n## 🤝 Acuerdos de clase\n- Ser amable y respetuosa\n- Participar activamente\n- Ayudar a las compañeras\n- Hacer preguntas cuando tengamos dudas\n\n## 🎯 Objetivo de la clase\nAprenderemos a usar useEffect para manejar efectos secundarios en nuestros componentes de React y simular cargas de datos.\n\n## 🤔 Pregunta inicial\n¿Alguna vez han esperado que cargue una página web o una app? ¿Cómo saben que está cargando?\n\n## 📱 Ejemplos de carga en apps que usamos\n- Instagram: Círculo girando mientras cargan las fotos\n- Netflix: Animación mientras carga una película\n- WhatsApp: Relojito mientras envía un mensaje\n\n## 🔄 ¿Qué es un efecto secundario?\nSon acciones que ocurren \"extra\" además del renderizado normal:\n- Cargar datos de un servidor\n- Suscribirse a eventos\n- Modificar el DOM manualmente\n- Guardar datos en localStorage\n\n## 🎣 Introduciendo useEffect\n```jsx\nuseEffect(() => {\n  // Código que queremos ejecutar\n}, []);\n```\n\n## 🎬 Casos de uso comunes\n1. Ejecutar código cuando el componente se monta\n2. Ejecutar código cuando cambia un estado\n3. Limpiar recursos cuando el componente se desmonta\n\n## 💡 Actividad práctica 1: Mi primer useEffect\nCreemos un componente que muestre un mensaje de \"¡Bienvenida!\" cuando se monte:\n\n```jsx\nfunction Bienvenida() {\n  useEffect(() => {\n    alert(\"¡Bienvenida a la app!\");\n  }, []);\n\n  return <h1>Mi primera app con useEffect</h1>;\n}\n```\n\n## 🔄 Array de dependencias\nEl segundo argumento de useEffect controla cuándo se ejecuta:\n- [] : Solo al montar\n- [variable] : Cuando cambia esa variable\n- nada : En cada renderizado\n\n## 💪 Actividad práctica 2: Contador con efecto\nHaremos un contador que muestre un mensaje cuando llegue a 10:\n\n```jsx\nfunction Contador() {\n  const [cuenta, setCuenta] = useState(0);\n\n  useEffect(() => {\n    if (cuenta === 10) {\n      alert(\"¡Llegaste a 10!\");\n    }\n  }, [cuenta]);\n\n  return (\n    <div>\n      <h2>Contador: {cuenta}</h2>\n      <button onClick={() => setCuenta(cuenta + 1)}>+1</button>\n    </div>\n  );\n}\n```\n\n## 🌟 Simulación de carga\nVamos a crear un componente que simule estar cargando datos:\n\n```jsx\nfunction CargandoDatos() {\n  const [cargando, setCargando] = useState(true);\n  const [datos, setDatos] = useState([]);\n\n  useEffect(() => {\n    setTimeout(() => {\n      setDatos(['Pizza', 'Hamburguesa', 'Tacos']);\n      setCargando(false);\n    }, 2000);\n  }, []);\n\n  if (cargando) {\n    return <p>Cargando...</p>;\n  }\n\n  return (\n    <ul>\n      {datos.map(comida => <li key={comida}>{comida}</li>)}\n    </ul>\n  );\n}\n```\n\n## 🎨 Mini-proyecto: Lista de tareas con estado de carga\nCrearemos una lista de tareas que simule cargar datos al inicio:\n\n1. Estado para tareas y cargando\n2. useEffect para simular carga inicial\n3. Mostrar \"Cargando...\" mientras los datos llegan\n4. Mostrar la lista cuando esté lista\n\n## 🧹 Limpieza de efectos\nA veces necesitamos limpiar lo que hicimos:\n\n```jsx\nuseEffect(() => {\n  // Efecto\n  return () => {\n    // Limpieza\n  };\n}, []);\n```\n\n## 🎯 Ejercicio final\nCrea un componente Temporizador que:\n1. Muestre una cuenta regresiva desde 10\n2. Use useEffect para actualizar cada segundo\n3. Limpie el intervalo cuando se desmonte\n\n## 🎉 Repaso\n- useEffect nos permite manejar efectos secundarios\n- El array de dependencias controla cuándo se ejecuta\n- Podemos simular estados de carga\n- La limpieza es importante para evitar problemas\n\n## 👩‍💻 Tarea\nModifica el ejercicio del Temporizador para que:\n1. Permita elegir el tiempo inicial\n2. Muestre un mensaje cuando llegue a cero\n3. Tenga botones de pausa/continuar\n\n## 📚 Recursos adicionales\n- Documentación de React sobre useEffect\n- Ejemplos de patrones comunes\n- Buenas prácticas al usar efectos",
  "necesita_codigo": true,
  "codigo_actividades": "// Temporizador.jsx\nimport React, { useState, useEffect } from 'react';\n\nfunction Temporizador() {\n  const [tiempo, setTiempo] = useState(10);\n\n  useEffect(() => {\n    const intervalo = setInterval(() => {\n      setTiempo(tiempoActual => {\n        if (tiempoActual <= 0) {\n          clearInterval(intervalo);\n          return 0;\n        }\n        return tiempoActual - 1;\n      });\n    }, 1000);\n\n    return () => clearInterval(intervalo);\n  }, []);\n\n  return (\n    <div>\n      <h2>Tiempo restante: {tiempo}</h2>\n    </div>\n  );\n}\n\nexport default Temporizador;",
  "necesita_capturas": false,
  "capturas_info": {}
}